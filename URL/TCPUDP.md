> ### TCP/UDP面试（字节跳动面试复习）



* #### 网络模型

  * ##### OSI七层模型

  * ##### TCP/IP四层模型

  * ##### 数据的交互

* #### TCP/UDP

  * ##### TCP

    * ##### 三次握手

    * ##### 四次挥手

    * ##### TCP保证可靠的传输

  * ##### TCP与UDP



> ### 网络模型



##### OSI七层模型/【TCP/IP】四层模型图

![](https://github.com/TanLinRu/ImageHost/raw/master/URL/images/OSI七层模型与TCP四层模型.png)

> ##### 解析

##### OSI各层职责：

* ##### 物理层：底层数据传输，如网线、网卡标准

* ##### 数据链路层：定义数据的基本格式，如何传输，如何标识，网卡MAC地址

* ##### 网络层：定义IP编址，定义路由功能，如不同的设备的数据转发

* ##### 传输层：端到端传输数据的基本功能，如TCP/UDP

* ##### 会话层：控制应用程序之间的会话能力，如不同软件数据分发给不同的软件

* ##### 表示层：数据格式标识，基本压缩加密能力

* ##### 应用层：各种应用软件，包括WEB应用



##### TCP/IP模型是OSI模型的简化以及实现

##### TCP/IP协议中每层技术：

* ##### 数据传输层：ARP/RARP

* ##### 网络层：ICMP/IP

* ##### 传输层：TCP/UDP

* ##### 应用层：DNS/FTP/HTTP/SMTP/TELNET/IRC/WHOIS



##### 个人思考：那么数据在网络中传输时，都经历了什么？

> #### 举个例子



##### 参照上述的结构图，我个人思考（可能有误，大家自行寻找正确的）：假设一个程序，服务端（S）与客户端（C）的交互。当C发了请求给S时，那么C发出的请求数据会从应用层一层一层的往下传，然后从物理层传到S的物理层，再从S的物理层一层一层的传到S的应用层。同理，S返回数据给C时，也是一样的原理。（此处省略了三次握手，四次挥手的逻辑）。

##### 数据便是在计算机与计算机间通过网络进行这样的额传递，其中数据通过相对应的层级进行层层解包，以及附加自己要传递的数据信息，术语称为报头。

##### 在四层中，传输层数据称为段（Segments）,网络层数据称为包（Package）（IP数据报（数据报））,数据链路层数据称为帧（Frames）,物理层数据称为比特流（BITS），应用层的数据称为报文。

##### 具体图解如下（图片来源）：[图片来源][ https://blog.csdn.net/yaopeng_2005/article/details/7064869 ]

![]( https://github.com/TanLinRu/ImageHost/raw/master/URL/images/网络模型详解图.png )

> #### TCP

##### TCP(Transmission Control Protocol）传输控制协议)是一种**面向连接**、可靠的、基于字节流的传输层通信协议。

##### TCP通过校验和、序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输。

> #### 三次握手

##### 简单的实例图(图片来源《图解HTTP》)：

##### ![](https://github.com/TanLinRu/ImageHost/raw/master/URL/images/图解HTTP.png)

##### 个人画的：

![三次握手](https://github.com/TanLinRu/ImageHost/raw/master/URL/images/三次握手.png)

> ##### 三次握手（为什么？怎么做？）

##### 三次握手的目的是建立可靠的通信信道，进而更为准确的传输数据和接收准确的数据。三次握手最主要的目的就是双方确认自己的接收和发送是否正常，进而更为安全的传输和接收数据。

> ##### 图解

##### 第一次握手：通过SYN,接收方确认发送方发送正常。

##### 第二次握手：通过SYN+ACK,发送方确认自己发送正常，接收也正常，接收方发送正常。

##### 第三次握手：通过ACK，接收方确认自己的接收正常。

##### 通过三次握手，双方确认自己的接收和发送数据行为都是正常的，进而开始传输数据。

> ##### 思考

##### 为什么还要传回SYN，传了SYN，为啥还要传ACK？

##### SYN是TCP/IP建立相关连接时使用的握手信号。在发送方与接收方之间建立正常的TCP网络连接时，发送方会首先发出一个SYN消息（接收方确认发送方发送消息成功），而接收方会返回一个SYN+ACK（确认字符）的消息（这步：发送方确认了自己的接收和发送消息是正确的，同时确认接收方的发送是正常的），最后发送方在返回一个ACK消息（接收方确认自己的接收和发送数据行为正常），最后开始双方的正常数据传输与接收。

##### 双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。 



> #### 四次挥手

##### 简单图解：

![](https://github.com/TanLinRu/ImageHost/raw/master/URL/images/四次挥手.png)

> ##### 图解

##### 第一次挥手：主动关闭方发出一个FIN，用来关闭主动关闭方与被动关闭方的数据传输。

##### 第二次挥手：被动关闭方接收到这个FIN信号，然后它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号 。此时主动关闭方属于半关闭状态。

##### 第三次挥手：被动关闭方发送FIN信号，此信号告诉主动关闭方，自身不再进行数据的传输。

##### 第四次挥手：主动关闭方接收到被动关闭方的FIN信号，返回ACK确认信号，此时双方通道正式关闭。

> ##### 为什么要四次挥手？

##### 正如打电话一样，你想挂了（第一次挥手），但你的朋友知道你想挂了电话（第二次挥手），但他还有话要说，最后他终于把话说完了（第三次挥手），你会了一句好的（第四次挥手），那么这次通话就算完了。

##### 为什么不可以三次挥手呢？因为当你想关闭的时候，而正如例子中的一样，你朋友还有话要讲，那如果直接挂了的话，你就听不到你朋友接下来要讲的是什么，那在网络中也会丢失相关的数据，所以这也是为什么要四次挥手的原因。

> #### TCP保证可靠的传输

* ##### 数据会被TCP分割成认为最合适发送的数据块

* ##### TCP会给发送的每一个包进行相对应的编号，接收方对数据进行排序，然后有序的传输给应用层进行数据合并。

* ##### 校验和：TCP将保持它首部和数据的校验和。这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化 。如果收到段的检验和差错，TCP将会丢弃这个报文段和不确认收到此报文段。

* ##### TCP的接收端会丢弃重复的数据

* ##### 流量控制：TCP连接的每一方都有固定大小的缓冲区，TCP的接收端只允许发送端发送接收端缓冲区能容纳的数据。当接收方来不及处理发送方的数据时，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。（TCP利用滑动窗口实现流量控制）

* ##### 拥塞控制：当网络拥塞时，减少数据的发送

* ##### ARQ协议：为了实现可靠性传输，其基本原理就是每发完一个分组就停止发送，等待对方确认后，等待对方发送确认信号后，再发送下一个分组。

* ##### 超时重传：当TCP发出一个段后，启动一个定时器，等待接收端确认收到这个报文段，并返回ACK确认信号。如果没有及时的收到接收端的ACK信号，将会重发这个报文段。





> #### TCP|UDP对比

| 类型 | 是否面向连接 | 传输可靠性 | 传输形式 | 传输速率 | 所需资源 | 应用场景                             | 首部字节                 |
| ---- | ------------ | ---------- | -------- | -------- | -------- | ------------------------------------ | ------------------------ |
| TCP  | 面向连接     | 可靠       | 字节流   | 慢       | 多       | 要求通信可靠（如文件传输，邮件体验） | 20-60                    |
| UDP  | 无连接       | 不可开     | 报文     | 快       | 少       | 要求通信效率高（如域名转换）         | 8个字节（由4个字段组成） |



> ##### 学习文档，如有误处，还望见谅指出，此文档永久更新（根据自己的学习）