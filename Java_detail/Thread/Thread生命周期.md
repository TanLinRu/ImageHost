### Thread-生命周期

* ##### Thread线程状态

* ##### Thread生命周期函数

> ##### Thread生命周期

##### 在JDK源码中 State.java这个枚举类中定义了thread线程状态

State.java（作为Threa的内部类）

~~~

    public enum State {
        /**
         * 尚未启动的线程的线程状态.
         */
        NEW,

        /**
         * 可运行线程的线程状态。状态为可运行
         *的线程正在Java虚拟机中执行，但是
         *可能正在等待来自操作系统
         *的其他资源，例如处理器。
         */
        RUNNABLE,

        / ** 
        *线程的线程状态被阻塞，等待监视器锁定。 
        *处于阻塞状态的线程正在等待监视器锁定
        *输入同步块/方法或
        *调用
        * {@link Object＃wait（）Object.wait}后重新输入同步块/方法。 
        * /
        BLOCKED,

        / ** 
        *等待线程的线程状态。 
        *由于调用以下其中一种方法，线程处于等待状态：
        * <ul> 
        * <li> {@ link Object＃wait（）Object.wait}无超时</ li> 
        * <li> { @link #join（）Thread.join}没有超时</ li> 
        * <li> {@ link LockSupport＃park（）LockSupport.park} </ li> 
        * </ ul> 
        * 
        * <p>等待状态正在等待另一个线程*执行特定操作。 
        * 
        *例如，在某个对象上调用<tt> Object.wait（）</ tt> 
        *的线程正在等待另一个线程调用
        * <tt> Object.notify（）</ tt>或<tt>该对象上的Object.notifyAll（）</ tt>。名为<tt> Thread.join（）</ tt> 
        *的线程正在等待指定的线程终止。 
        * /
        WAITING,

        / ** 
        *具有指定等待时间的等待线程的线程状态。 
        *线程由于以指定的正等待时间调用以下方法之一而处于定时等待状态：
        * <ul> 
        * <li> {@ link #sleep Thread.sleep} </ li> 
        * <li> {@link Object＃wait（long）Object.wait}超时</ li> 
        * <li> {@ link #join（long）Thread.join}超时</ li> 
        * <li> {@ link LockSupport＃ parkNanos LockSupport.parkNanos} </ li> 
        * <li> {@ link LockSupport＃parkUntil LockSupport.parkUntil} </ li> 
        * </ ul> 
        * /
        TIMED_WAITING,

       / ** 
       *终止线程的线程状态。 
       *线程已完成执行。 
       * /
        TERMINATED;
    }

    / ** 
    *返回此线程的状态。 
    *此方法设计用于监视系统状态，
    *不用于同步控制。 
    * 
    * @返回此线程的状态。 
    * @自1.5起
    * /
    public State getState() {
        // get current thread state
        return sun.misc.VM.toThreadState(threadStatus);
    }

}

~~~

##### 从上述源码中可以看到，线程的状态新建，就绪，运行，阻塞，死亡这种状态。

##### 其次这五种状态实际上是有cpu进行修改的，而不是通过java虚拟机进行修改。

1. ##### 新建状态，当程序使用new关键字创建了一个线程之后，该线程就处于新建状态，此时仅由JVM为其分配内存，并初始化其成员变量的值

2. ##### 就绪状态，当线程对象调用了start()方法之后，该线程处于就绪状态。Java虚拟机会为其创建方法调用栈和程序计数器，等待调度运行

3. ##### 运行状态，如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态

4. ##### 阻塞状态，当处于运行状态的线程失去所占用资源之后，便进入阻塞状态

5. ##### 在线程的生命周期当中，线程的各种状态的转换过程

> ##### Thread生命周期函数

* ##### 新建和就绪状态

  当程序使用new关键字创建了一个线程之后，该线程就处于**新建状态**，此时它和其他的Java对象一样，仅仅由Java虚拟机为其分配内存，并初始化其成员变量的值。此时的线程对象没有表现出任何线程的动态特征，程序也不会执行线程的线程执行体。

  当线程对象调用了start()方法之后，该线程处于**就绪状态**。Java虚拟机会为其创建方法调用栈和程序计数器，处于这个状态中的线程并没有开始运行，只是表示该线程可以运行了。至于该线程何时开始运行，取决于JVM里线程调度器的调度。

  ##### **注意**：启动线程使用start()方法，而不是run()方法。永远不要调用线程对象的run()方法。调用start0方法来启动线程，系统会把该run()方法当成线程执行体来处理；但如果直按调用线程对象的run()方法，则run()方法立即就会被执行，而且在run()方法返回之前其他线程无法并发执行。也就是说，系统把线程对象当成一个普通对象，而run()方法也是一个普通方法，而不是线程执行体。需要指出的是，调用了线程的run()方法之后，该线程已经不再处于新建状态，不要再次调用线程对象的start()方法。只能对处于新建状态的线程调用start()方法，否则将引发IllegaIThreadStateExccption异常。

  调用线程对象的start()方法之后，该线程立即进入就绪状态——就绪状态相当于"**等待执行**"，但该线程并未真正进入运行状态。如果希望调用子线程的start()方法后子线程立即开始执行，程序可以使用Thread.sleep(1) 来让当前运行的线程（主线程）睡眠1毫秒，1毫秒就够了，因为在这1毫秒内CPU不会空闲，它会去执行另一个处于就绪状态的线程，这样就可以让子线程立即开始执行。

* ##### 运行和阻塞状态

  * ##### **线程调度**

    如果处于就绪状态的线程获得了CPU，开始执行run()方法的线程执行体，则该线程处于运行状态，如果计算机只有一个CPU。那么在任何时刻只有一个线程处于运行状态，当然在一个多处理器的机器上，将会有多个线程并行执行；当线程数大于处理器数时，依然会存在多个线程在同一个CPU上轮换的现象。

    当一个线程开始运行后，它不可能一直处于运行状态（除非它的线程执行体足够短，瞬间就执行结束了）。线程在运行过程中需要被中断，目的是使其他线程获得执行的机会，线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言，系统会给每个可执行的线程一个小时间段来处理任务；当该时间段用完后，系统就会剥夺该线程所占用的资源，让其他线程获得执行的机会。在选择下一个线程时，系统会考虑线程的优先级。

    所有现代的桌面和服务器操作系统都采用抢占式调度策略，但一些小型设备如手机则可能采用协作式调度策略，在这样的系统中，只有当一个线程调用了它的sleep()或yield()方法后才会放弃所占用的资源——也就是必须由该线程主动放弃所占用的资源。

  * ##### 线程阻塞

    当发生如下情况时，线程将会进入阻塞状态

    ① 线程调用sleep()方法主动放弃所占用的处理器资源

    ② 线程调用了一个阻塞式IO方法，在该方法返回之前，该线程被阻塞

    ③ 线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有。关于同步监视器的知识、后面将存更深入的介绍

    ④ 线程在等待某个通知（notify）

    ⑤ 程序调用了线程的suspend()方法将该线程挂起。但这个方法容易导致死锁，所以应该尽量避免使用该方法

    当前正在执行的线程被阻塞之后，其他线程就可以获得执行的机会。被阻塞的线程会在合适的时候重新进入就绪状态，注意是就绪状态而不是运行状态。也就是说，被阻塞线程的阻塞解除后，必须重新等待线程调度器再次调度它。

  * ### 解除阻塞

    针对上面几种情况，当发生如下特定的情况时可以**解除上面的阻塞**，让该线程重新**进入就绪状态**：

    **①** 调用sleep()方法的线程经过了指定时间。

    **②** 线程调用的阻塞式IO方法已经返回。

    **③** 线程成功地获得了试图取得的同步监视器。

    **④** 线程正在等待某个通知时，其他线程发出了个通知。

    **⑤** 处于挂起状态的线程被调甩了resdme()恢复方法。

* ## 线程死亡

  线程会以如下3种方式结束，结束后就处于**死亡状态**：

  **①** run()或call()方法执行完成，线程正常结束。

  **②** 线程抛出一个未捕获的Exception或Error。

  **③** 直接调用该线程stop()方法来结束该线程——该方法容易导致死锁，通常不推荐使用。



> 资料参考：
>
> java官网
>
> 博客：https://www.cnblogs.com/sunddenly/p/4106562.html