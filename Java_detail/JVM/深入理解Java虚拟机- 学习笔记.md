## JVM

### 运行时数据区

​	Java虚拟机中有如下的相关数据区域，这些区域有各自的用途，以及创建时间和销毁的时间，有的区域会随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束和销毁。

​	根据《Java虚拟机规范》中规定。Java虚拟机所管理的内存会包括如下的几个运行时数据区域：（黄色为线程共享的数据区域，白色的为线程隔离的数据区（除了本地方法库））

![image-20210109142817908](https://raw.githubusercontent.com/TanLinRu/ImageHost/master/images/image-20210109142817908.png)

#### 程序计数器（私有，无异常）

​	程序计数器（Program Counter Register）是一块较小的内存空间，其可以看做是当前线程所执行的字节码行号指示器。

​	**在Java虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要被执行的字节码指令，同时字节码解析器还是程序流的指示器**

​	**在程序控制中的分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖程序计数器**

​	当程序中一个线程正在执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，但如果执行的是本地的（Native）方法，这个计数器值则应为空（Undefined）。**此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何OOM（Out Of Memory Error）情况的区域**

​	程序计数器是线程私有的

~~~
由于Java虚拟机的多线程的线程间进行切换，分配处理器执行时间的方式来实现的。在任何一个确定的时刻，一个处理器（对于多喝处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程能够在切换后恢复到正确的执行位置，每个线程都需要有一个独立的程序计数器，并且各个线程之间的计数器互不影响，独立存储
~~~

#### Java虚拟机栈（栈空间）（私有、异常：StackOutMemoryError、OutOfMemoryError）

​	Java虚拟机栈（Java virtual mechine stack）线程私有，**其生命周期与线程相同**。虚拟机栈描述的是Java方法执行的线程内存模型：**每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧(Stack Frame)。**在栈空间中，没

在栈空间中，栈帧用于**存储局部变量表、操作数栈、动态链接、方法出口等信息**。

​	在栈帧中的局部变量表中，存放了编译期可知的各种Java虚拟机**基本数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，**其并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能指向一个代表对象句柄或者其他与此对象相关的位置**）、**returnAddress类型**（指向一条字节码指令的地址）

​	这些数据类型在局部变量表中存储空间以及局部变量槽（slot）来表示，**其中64位长度的long和doub类型的数据会占用两个变量槽，其余数据类型占用一个。局部变量表所需的内存空间在编译期间完成分配。当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小**

~~~
此处说的局部变量的大小，指的是变量槽的数量
其次，虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或更多）来实现一个变量槽，这完全是由具体虚拟机实现自行决定的事情。		
~~~

​	在《Java虚拟规范》中，对这个内存区域规定了两类异常状况：

* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlow Error异常
* 如果Java虚拟机栈容量可以动态扩展，当栈扩展无法申请到足够的内存会抛出OutOfMemoryError异常

> 小知识

​	Java内存区域笼统的划分为堆内存（Heap）和栈内存（stack）,这种划分方式直接继承自传统的C、C++的内存布局（这种划分在Java语言中较为粗糙，实际上Java虚拟机中内存区域的划分更为复杂）

​	HotSpot虚拟机的栈容量是 不可以动态扩展的（即HotSpot虚拟机上是不会由于虚拟机栈无法动态扩展而导致OutOfMemory异常，只要线程申请栈空间成功了就不会OOM，申请失败就会OOM）

#### 本地方法栈（线程共享，异常：StackOutMemoryError、OutOfMemoryError）

​	在Java虚拟机中，栈空间是为java方法服务，而本地方法栈是为虚拟机使用到的本地（Native）方法服务

**	与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverFlowError和OutOfMemoryError异常**

**HotSpot虚拟机直接就把本地方法栈和虚拟机栈合二为一**。

> 补充

​	《Java虚拟机规范》对本地方法栈中方法使用到的语言，使用方式与数据结构并没有任何强制规定，可由具体的虚拟机进行相关的定制化实现。

#### Java堆（堆内存、GC堆，线程共享，异常：OutOfMemoryError，垃圾收集器管理区域）

​	Java堆（java heap）是**虚拟机所管理的内存中最大的一块**。堆内存是被所有线程共享的一块内存区域。**在JVM启动时创建，次内存区域的唯一目的就是存放对象实例。**在《Java虚拟机规范》中对堆内存的描述，**所有的对象实例以及数组都应当在堆内存上分配**。但事实上，随着**逃逸分析技术、栈上分配、标量替换等优化手段、导致Java对象实例不一定会都分配到堆内存上**

​	**从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（Thread Local Allocaton Buffer,TLAB）,以提升对象分配时的效率**

​	在Java堆中会有很多区域的细分，这些细分的目的更多是为了更好的回收内存或更快的分配内存。

根据《Java虚拟机规范》，Java堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续。但同时，多数虚拟机实现出于实现简单、存储高效的考虑，可能会要求连续的内存空间。

​	Java堆既可被实现成固定大小的，也可以是可扩展的。但是当前主流的Java虚拟机都是按照可扩展的来实现的**（通过参数Xmx和-Xms参数来设定）**

​	**如果在堆内存中，当无法完成实例的内存分配，且无法再扩展时，Java虚拟机会抛出OutOfMemoryError异常**

Java堆中经常出现（待确认细化）：

* 新生代
* 老年代
* 永久代
* Eden空间
* From Survivor空间
* To Surivivor空间

#### 方法区（线程共享，异常）

​	方法区（Method area）与Java堆一样，是一个线程共享的内存区域，**用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据**

​	《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但其别名为非堆（Non-heap）,目的是与Java堆区进行区分。除此之外，对方法区的相关约束是非常宽松的，处理和Java堆一样不需要连续的内存和可以选择固定大小或可扩展外，甚至还可以选择不实现垃圾收集，**相对而言，方法区的垃圾收集行为比较少出现。** 

​	**方法区中内存回收的目标主要是针对常量池的回收和对类型的卸载** 

​	一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时的确很有必要

​	**根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配时，将抛出OutOfMemeryError异常**

> 补充

​	在JDK8以前，方法区称呼为”永久代“（Permanent Generation）或将两者混为一谈。但本质上两者并不等价，**仅仅是当时HotSpot虚拟机设计团队选择吧收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存**

​	对于其他虚拟机实现，例如BEA JRockit,IBM J9等来说，是不存在永久代的概念的

​	有极少数方法（例如String::intern()）会因为永久代的原因而导致不同的虚拟机下有不同的表现

​	在JDK6的时候，HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计划

​	JDK7 Hotspot，把原本放在永久代的字符串常量池、静态变量等移出，到了JDK8，完全放弃永久代，并改用与Jrockit，J9一样在本地内存中实现元空间（Meta-Space来代替）

~~~
具体相关的方法区与永久代关系 --- 2.2.5方法区
~~~



### 零散点

* Java虚拟机中区域的划分仅仅是一部分垃圾收集器的共同特性或设计风格，而非某个Java虚拟机具体实现的固有的内存布局，更不是《Java虚拟机规范》中对Java堆的进一步细致划分
* 从回收内存的角度，现在垃圾收集器大部分都是基于分代收集理论设计
*  HotSpot垃圾收集器基于经典分代来设计，需要新生代、老年代收集器搭配才能工作。但按照目前，Hotspot里面出现了不采用分代设计的新垃圾收集器。

### 参考资料

《深入理解Java虚拟机》