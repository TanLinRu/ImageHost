16、尽量在合适的场合使用``单例``

使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：

（1）控制资源的使用，通过线程同步来控制资源的并发访问

（2）控制实例的产生，以达到节约资源的目的

（3）控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信



18、及时清除不再需要的会话

为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为 30 分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据 MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用 HttpSession 的 invalidate()方法清除会话。

19、实现 ``RandomAccess`` 接口的集合比如 ``ArrayList``，应当使用最普通的 ``for`` 循环而不是 ``foreach ``循环来遍历

这是 JDK 推荐给用户的。JDK API 对于 ``RandomAccess`` 接口的解释是：实现 ``RandomAccess`` 接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。实际经验表明，实现 ``RandomAccess ``接口的类实``例，假如是随机访问的，使用普通 ``for ``循环效率将高于使用 ``foreach 循环；反过来，如果是顺序访问的，则使用 ``Iterator`` 会效率更高。可以使用类似如下的代码作判断：

~~~
if (list instanceof RandomAccess)
{ 
	for (int i = 0; i < list.size(); i++){}
}else{
	Iterator<?> iterator = list.iterable();
	while (iterator.hasNext()){
  	iterator.next();
  }
}
~~~

``foreach`` 循环的底层实现原理就是迭代器 ``Iterator``
参见 Java 语法糖：

* 可变长度参数以及 foreach 循环原理。所以后半句”反过来，如果是顺序访问的，则使用 Iterator 会效率更高”的意思就是顺序访问的那些类实例，使用 foreach 循环去遍历。

21、将常量声明为 ``static final``，并以 ****大写命名****

这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量

23、程序运行过程中避免使用反射

关于，请参见反射。反射是 Java 提供给用户一个很强大的功能，功能强大往往意味着效率不高。不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是 ``Method ``的 ``invoke`` 方法，如果确实有必要，一种建议性的做法是将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存—-用户只关心和对端交互的时候获取最快的响应速度，并不关心对端的项目启动花多久时间。