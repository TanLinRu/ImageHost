### Spring - Transactional

* ACID（事务特性）与 Mysql事务级别
* Spring Transactional 传播行为

> ACID事务特性

- 原子性：强调事务的不可分割
- 一致性：事务的执行前后数据完整性保持一致
- 隔离性：一个事务的执行过程中，不应该受到其他事务的干扰
- 持久性：事务一旦结束，数据持久到数据库

在mysql中有以下几种事务隔离级别与可能会发生的数据问题：

| 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| ---------------------------- | ------------------ | -------------------------------- | -------------------- |
| 未提交读（Read uncommitted） | 可能               | 可能                             | 可能                 |
| 已提交读（Read committed）   | 不可能             | 可能                             | 可能                 |
| 可重复读（Repeatable read）  | 不可能             | 不可能                           | 可能                 |
| 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |

级别越高，资源的消耗以及相应的数据处理速度也是会下降的。

一些课外的思考

~~~~shell
redo log称为重做日志，用来保证事务的原子性和持久性，undo log称为回滚日志，用来保证事务的一致*。*务的隔离性通过锁机制来实现。

事务中的原子性与持久性都是通过redo log（重做日志）来实现
一致性的话，就是使用了undo log（回滚日志）来实现
隔离性是通过lbcc（锁机制）或mvcc（数据快照）去实现，通过隔离性保证数据的一致性

在并发，和innodb中不同的事务隔离级别最后都是发生的数据一致性的问题。
例如：在ead Committed（读取提交内容）级别中，数据的读取都是不加锁的，但是数据的写入、修改和删除是需要加锁的。不加读锁，只加写锁最后导致的就是不可重读跟 幻读的出现。
不同的事务隔离级别，使用不同的锁策略，去解决不同的事务并发的问题。事务的隔离级别就是为了解决事务中并发的问题而生的。

~~~~

> spring 事务

- PROPAGATION_**REQUIRED**：支持当前事务， **如果当前没有事务，就新建事务（常用）**
- PROPAGATION_**SUPPORTS**：支持当前事务，**如果当前没有事务，就以非事务方式执行**
- PROPAGATION_**MANDATORY**：支持当前事务，**如果当前没有事务，就抛出异常**
- PROPAGATION_**REQUIRES_NEW**：新建事务，**如果当前存在事务，把当前事务挂起**
- PROPAGATIPN_**NOT_SUPPORTED**：以非事务方式执行操作，**如果当前存在事务，就把当前事务挂起**
- PROPAGATION_**NEVER**：以非事务方式执行，**如果当前存在事务，则抛出异常**
- 
- PROPAGARION_**NESTED**：**如果当前存在事务，则嵌套事务内执行，如果当前没有事务，则进行与PROPAGATION_REQUIRED类似操作。**

#### spring的事务的5个隔离级别

- ISOLATION_DEFAULT: 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认事务隔离级别。

#### 以下四个与JDBC的隔离级别相对应

- ISOLATION_READ_UNCOMMITTED（读取未提交）：这是事务最低的隔离级别，它允许另外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复，虚幻读。
- ISOLATION_REPEATABLE_COMMITTED（读取已提交）：保证一个事务修改的数据提交后，才可被另外一个事务读取。另外一个事务不能读取该事务为提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复和虚幻读。
- ISOLATION_REPEATABLE_READ（可重复度）：这种事务隔离级别可以防止脏读，不可重读。但可能出现虚幻读。它除了保证一个事务不能读取另外一个事务尚未提交的数据外，还保证了避免不可重读的情况产生。
- ISOLATION_SERIALIZABLE（可串行化）：这是花费最高代价，但是最可靠的事务隔离级别，事务处理为顺序执行，除了防止脏读，不可重读外，还避免了虚幻读。

> 粗略总结了一下

>资料来源：
>
>《高性能Mysql》